from flask import Flask, render_template, request, redirect, url_for, flash, abort
from flask_login import LoginManager, login_user, logout_user, login_required, current_user
from flask_bcrypt import Bcrypt
from flask_wtf import CSRFProtect
from flask_wtf.csrf import generate_csrf
from dotenv import load_dotenv
from datetime import datetime, timezone as dt_timezone
from pytz import timezone as pytz_timezone
from urllib.parse import urlparse, urljoin, quote_plus
from flask_migrate import Migrate
from flask_mail import Mail, Message
from itsdangerous import URLSafeTimedSerializer, BadSignature, SignatureExpired
from sqlalchemy import func
import stripe, qrcode, io, base64, os

from forms import LoginForm, RegisterForm, TicketForm
from models import db, User, Ticket

# ------------------ Setup ------------------
load_dotenv()

app = Flask(__name__)
# config.py must define: SECRET_KEY, SQLALCHEMY_DATABASE_URI, STRIPE_SECRET_KEY, mail settings, etc.
app.config.from_pyfile('config.py')

db.init_app(app)
migrate = Migrate(app, db)

bcrypt = Bcrypt(app)
csrf = CSRFProtect(app)
app.jinja_env.globals['csrf_token'] = generate_csrf

login_manager = LoginManager(app)
login_manager.login_view = 'login'

# Stripe
stripe.api_key = os.getenv("STRIPE_SECRET_KEY")

# Mail
mail = Mail(app)

# Stripe Connect blueprint (optional)
from connect_routes import connect_bp
app.register_blueprint(connect_bp)
csrf.exempt(connect_bp)  # allow JS POSTs to /api/connect/*

# ------------------ Helpers ------------------
@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

def is_safe_url(target: str) -> bool:
    host_url = urlparse(request.host_url)
    test_url = urlparse(urljoin(request.host_url, target))
    return (test_url.scheme in ("http", "https")) and (host_url.netloc == test_url.netloc)

# ----- Email Confirmation helpers -----
def _ts() -> URLSafeTimedSerializer:
    return URLSafeTimedSerializer(
        app.config["SECRET_KEY"],
        salt=app.config["SECURITY_CONFIRM_SALT"]
    )

def generate_confirm_token(user_id: int) -> str:
    return _ts().dumps({"uid": user_id})

def verify_confirm_token(token: str, max_age: int | None = None):
    if max_age is None:
        max_age = app.config.get("CONFIRM_TOKEN_EXPIRATION", 3600)  # seconds
    try:
        data = _ts().loads(token, max_age=max_age)
        return data.get("uid")
    except (SignatureExpired, BadSignature):
        return None

def send_confirmation_email(user: User):
    token = generate_confirm_token(user.id)
    confirm_url = url_for("confirm_email", token=token, _external=True)
    subject = "Confirm your email"

    text_body = render_template("emails/confirm.txt", user=user, confirm_url=confirm_url)
    html_body = render_template("emails/confirm.html", user=user, confirm_url=confirm_url)

    msg = Message(subject=subject, recipients=[user.email], body=text_body, html=html_body)
    mail.send(msg)

# ------------------ Auth ------------------
@app.route('/register', methods=['GET', 'POST'])
def register():
    form = RegisterForm()
    if form.validate_on_submit():
        email = (form.email.data or "").strip().lower()
        # case-insensitive uniqueness
        existing_user = User.query.filter(func.lower(User.email) == email).first()
        if existing_user:
            flash('Email already registered.')
            return redirect(url_for('register'))

        hashed_pw = bcrypt.generate_password_hash(form.password.data).decode('utf-8')
        new_user = User(email=email, password=hashed_pw)
        db.session.add(new_user)
        db.session.commit()

        # Send confirmation email
        try:
            send_confirmation_email(new_user)
            flash('Registration successful! Check your email to confirm before logging in.')
        except Exception:
            app.logger.exception("Signup confirmation email failed")
            flash('Registration succeeded, but we could not send the confirmation email. '
                  'Please log in and use “Send confirmation email” from your dashboard.')

        return redirect(url_for('login'))
    return render_template('register.html', form=form)

@app.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        email = (form.email.data or "").strip().lower()
        user = User.query.filter(func.lower(User.email) == email).first()
        if user and bcrypt.check_password_hash(user.password, form.password.data):
            login_user(user)

            # ---- Stripe Connect gate after login ----
            needs_payouts = False
            acct_id = getattr(user, "stripe_account_id", None)

            if not acct_id or not getattr(user, "charges_enabled", False):
                needs_payouts = True
            else:
                # Optional live check with Stripe
                try:
                    acct = stripe.Account.retrieve(acct_id)
                    needs_payouts = not (acct.charges_enabled and acct.payouts_enabled)
                except Exception:
                    needs_payouts = True

            if needs_payouts:
                return redirect(url_for('payouts'))

            next_url = request.args.get("next")
            if next_url and is_safe_url(next_url):
                return redirect(next_url)

            return redirect(url_for('index'))

        flash('Invalid email or password.')

    return render_template('login.html', form=form)
@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('login'))

@app.route('/settings', methods=['GET'])
@login_required
def settings():
    stripe_connect_link = url_for('payouts')
    return render_template('settings.html', user=current_user, stripe_connect_link=stripe_connect_link)

# ------------------ Dashboard (create up to 5 tickets) ------------------
@app.route('/dashboard', methods=['GET', 'POST'])
@login_required
def dashboard():
    form = TicketForm()
    tickets = Ticket.query.filter_by(user_id=current_user.id).all()

    if form.validate_on_submit():
        # Read slider value and clamp 5–20
        raw = request.form.get('fee_percent_override', '12')
        try:
            pct = float(raw)
        except (TypeError, ValueError):
            pct = 12.0
        pct = max(5.0, min(20.0, pct))

        # Persist the chosen fee at the user level
        current_user.fee_percent = pct

        # Create the ticket
        t = Ticket(
            name=form.name.data,
            price=form.price.data,
            user_id=current_user.id
        )
        db.session.add(t)
        db.session.commit()
        flash("Ticket added.")
        return redirect(url_for('dashboard'))

    return render_template('dashboard.html', form=form, tickets=tickets)

# ------------------ Home: generate QR for selected ticket ------------------
@app.route('/', methods=['GET', 'POST'])
@login_required
def index():
    # Gate: force payouts setup before accessing tickets/QR
    if (not getattr(current_user, "stripe_account_id", None)
            or not getattr(current_user, "charges_enabled", False)):
        return redirect(url_for('payouts'))

    tickets = Ticket.query.filter_by(user_id=current_user.id).all()
    has_tickets = len(tickets) > 0

    if request.method == 'POST':
        ticket_id_raw = request.form.get('ticket_id')
        if not ticket_id_raw:
            flash("Please select a ticket first.")
            return redirect(url_for('index'))

        try:
            ticket_id = int(ticket_id_raw)
        except (TypeError, ValueError):
            flash("Invalid ticket selection.")
            return redirect(url_for('index'))

        sel = Ticket.query.get(ticket_id)
        if not sel or sel.user_id != current_user.id:
            flash("Ticket not found or not yours.")
            return redirect(url_for('index'))

        # Percent-based fee
        base_price = float(sel.price)
        pct = sel.fee_percent or getattr(current_user, "fee_percent", 12.0)
        pct = max(5.0, min(20.0, float(pct)))

        fee_total = base_price * (pct / 100.0)
        total_price = base_price + fee_total

        total_cents = int(round(total_price * 100))
        platform_fee_cents = int(round((fee_total * 0.5) * 100))  # your half of the fee
        platform_fee_cents = min(platform_fee_cents, max(total_cents - 1, 0))

        success_url = (
            "https://teameventlock.com/success"
            f"?ticket={quote_plus(sel.name)}&price={total_price:.2f}"
        )

        try:
            session = stripe.checkout.Session.create(
                mode='payment',
                line_items=[{
                    'price_data': {
                        'currency': 'usd',
                        'product_data': {'name': sel.name},
                        'unit_amount': total_cents,
                    },
                    'quantity': 1,
                }],
                success_url=success_url,
                cancel_url=request.host_url,
                payment_intent_data={
                    'application_fee_amount': platform_fee_cents,
                    'transfer_data': {'destination': current_user.stripe_account_id},
                    'on_behalf_of': current_user.stripe_account_id,
                },
            )
            print(f"[INDEX] Session {session.id} total_cents={total_cents} fee_half_cents={platform_fee_cents} pct={pct}")
        except Exception as e:
            print(f"[INDEX][StripeError] {e}")
            flash("Couldn’t start checkout with Stripe. Please try again.")
            return redirect(url_for('index'))

        # Generate QR for the session URL
        try:
            qr = qrcode.make(session.url)
            buffered = io.BytesIO()
            qr.save(buffered, format="PNG")
            img_str = base64.b64encode(buffered.getvalue()).decode()
        except Exception as e:
            print(f"[INDEX][QRError] {e}")
            flash("Failed to generate the QR code.")
            return redirect(url_for('index'))

        return render_template(
            'qrcode.html',
            img_data=img_str,
            ticket_name=sel.name,
            total_price=total_price
        )

    # GET
    return render_template('index.html', tickets=tickets, has_tickets=has_tickets)

# ------------------ Payouts (Stripe Connect onboarding) ------------------
@app.route('/payouts')
@login_required
def payouts():
    return render_template('payouts.html')

# ------------------ Email confirmation routes ------------------
@app.route("/confirm")
@login_required
def send_confirm():
    if getattr(current_user, "is_confirmed", False):
        flash("Your email is already confirmed.", "info")
        return redirect(url_for("dashboard"))
    try:
        send_confirmation_email(current_user)
        flash("Confirmation email sent. Check your inbox.", "success")
    except Exception:
        app.logger.exception("Failed to send confirmation email")
        flash("Could not send confirmation email. Please try again.", "error")
    return redirect(url_for("dashboard"))

@app.route("/confirm/<token>")
@login_required
def confirm_email(token):
    uid = verify_confirm_token(token)
    if not uid or uid != current_user.id:
        flash("Invalid or expired confirmation link.", "error")
        return redirect(url_for("dashboard"))

    if current_user.email_confirmed_at:
        flash("Email already confirmed.", "info")
        return redirect(url_for("dashboard"))

    current_user.email_confirmed_at = datetime.now(dt_timezone.utc)
    db.session.commit()
    flash("Email confirmed! Thanks.", "success")
    return redirect(url_for("dashboard"))

# ------------------ Misc ------------------
@app.route('/ticket/<int:ticket_id>')
def ticket_scan(ticket_id):
    t = Ticket.query.get_or_404(ticket_id)
    return f"Scanned ticket: {t.name} - ${t.price}"

@app.route('/success')
def success():
    eastern = pytz_timezone('US/Eastern')
    ticket = request.args.get('ticket', default='Unknown Ticket')
    price = request.args.get('price', default='0.00')
    timestamp = datetime.now(eastern).strftime('%B %d, %Y at %I:%M %p')
    return render_template('success.html', ticket=ticket, price=price, timestamp=timestamp)

@app.route('/_debug')
def debug_check():
    return "✔ App is running"

@app.route('/ticket/<int:ticket_id>/delete', methods=['POST'])
@login_required
def delete_ticket(ticket_id):
    t = Ticket.query.get_or_404(ticket_id)
    if t.user_id != current_user.id:
        abort(403)
    db.session.delete(t)
    db.session.commit()
    flash('Ticket deleted.')
    return redirect(url_for('dashboard'))

# ------------------ Local dev ------------------
if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(host='0.0.0.0', port=5000, debug=True)
